{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Weird Java & Kotlin Notes","text":"Weird Java &amp; Kotlin Notes <p>     My lifelong notes about the weird \ud83d\ude35\u200d\ud83d\udcab and wild \ud83e\udd2a features of Java &amp; Kotlin!      Explore the docs \u00bb Explore the docs (Kotlin) \u00bb Stream API Docs     \u00b7     Java 8 Cheat Sheet     \u00b7     Stream API Cheat Sheet </p> \ud83d\udcd4 Table of Contents <ol> <li> \ud83d\udcc4 About The Project 1a <ul> <li>\ud83d\udce3README Template</li> </ul> </li> </ol> \ud83d\udd16 Java <ol> <li> \ud83d\udcc4 Get An Array Of Map's Keys 1a-J <ul> <li>1a-J \u25b6\ufe0fExample</li> <li>1a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Swap Keys And Values In A Map 2a-J <ul> <li>2a-J \u25b6\ufe0fExample</li> <li>2a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Convert Array Of Primitives To A List Or Set 3a-J <ul> <li>3a-J \u25b6\ufe0fExample</li> <li>3a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Compare Wrapper Types 4a-J <ul> <li>4a-J \u25b6\ufe0fExample</li> <li>4a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Nest Methods 5a-J <ul> <li>5a-J \u25b6\ufe0fExample</li> <li>5a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Map Two Arrays To A HashMap 6a-J <ul> <li>6a-J \u25b6\ufe0fExample</li> <li>6a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Store Key-Value Pairs In A List 7a-J <ul> <li>7a-J \u25b6\ufe0fExample</li> <li>7a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Create A Node Priority Queue With Comparator 8a-J <ul> <li>8a-J \u25b6\ufe0fExample</li> <li>8a-J \ud83d\udca1Description</li> </ul> 8b-J <ul> <li>8b-J \u25b6\ufe0fExample</li> <li>8b-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Create A HashSet Of Arrays 9a-J <ul> <li>9a-J \u25b6\ufe0fExample</li> <li>9a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Lexicographically Sort A 2D List 10a-J <ul> <li>10a-J \u25b6\ufe0fExample</li> <li>10a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Iterate Through A HashMap 11a-J <ul> <li>11a-J \u25b6\ufe0fExample</li> <li>11a-J \ud83d\udca1Description</li> </ul> </li> <li> \ud83d\udcc4 Map Characters To An Array 12a-J <ul> <li>12a-J \u25b6\ufe0fExample</li> <li>12a-J \ud83d\udca1Description</li> </ul> </li> </ol>"},{"location":"#about-the-project","title":"About The Project","text":"<p>\u2003\u2003\u2003Hello! I'm Colston D. Bod-oy; I'm a React and Android developer, and I would be taking my 3rd year of college at the time that I made this repo. I'm an aspiring developer, and I would like to work for the big FAANG companies someday \ud83d\ude09.\u00a0\u00a0  </p> <p>\u2003\u2003\u2003I created this project so I could keep track of and recall things that I didn't know I could do in Java and Kotlin, as I've just recently started learning them on a deeper level. I hope you'll find these notes useful! \ud83d\ude0e.</p>"},{"location":"#readme-template","title":"README Template","text":"<p>Btw, here's where I got this template. Also, don't forget to follow me on my social media links.</p> <p>\ud83d\udc49 \ud83d\udcd2</p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#get-an-array-of-maps-keys","title":"Get An Array Of Map's Keys","text":"<p>\u2003\u2003\u2003I found these examples on Stack Overflow, which converts a set of map keys into an array.</p>"},{"location":"#1a-j-example","title":"1a-J Example","text":"<pre><code>import java.util.Arrays;\nimport java.util.HashMap;\n\nclass Main {\n    public static void main(String[] args) {\n        HashMap&lt;String, Integer&gt; stringsMap = new HashMap&lt;&gt;();\n        stringsMap.put(\"!V$q\", 16087526);\n        stringsMap.put(\"lW@$\", 64992058);\n        stringsMap.put(\"V*tx\", 61656601);\n        stringsMap.put(\"W*Ru\", 77778805);\n        stringsMap.put(\"b#Oo\", 44708273);\n\n        HashMap&lt;Integer, String&gt; integersMap = new HashMap&lt;&gt;();\n        integersMap.put(16087526, \"!V$q\");\n        integersMap.put(64992058, \"lW@$\");\n        integersMap.put(61656601, \"V*tx\");\n        integersMap.put(77778805, \"W*Ru\");\n        integersMap.put(44708273, \"b#Oo\");\n\n        HashMap&lt;String, String&gt; strNumsMap = new HashMap&lt;&gt;();\n        strNumsMap.put(\"16087526\", \"!V$q\");\n        strNumsMap.put(\"64992058\", \"lW@$\");\n        strNumsMap.put(\"61656601\", \"V*tx\");\n        strNumsMap.put(\"77778805\", \"W*Ru\");\n        strNumsMap.put(\"44708273\", \"b#Oo\");\n\n        // Output: [!V$q, b#Oo, lW@$, W*Ru, V*tx]\n        System.out.println(Arrays.toString(stringsMap      \n                .keySet().stream().toArray()));  \n\n        // Output: [16087526, 64992058, 61656601, 77778805, 44708273]\n        System.out.println(Arrays.toString(integersMap\n                .keySet().stream().mapToInt(Integer\n                ::intValue).toArray()));  \n\n        // Output: [61656601, 44708273, 77778805]\n        System.out.println(Arrays.toString(Arrays\n                .copyOfRange(strNumsMap.keySet().stream()\n                .mapToInt(Integer::parseInt).toArray(), \n                          0, 3)));  \n\n    }\n}\n</code></pre>"},{"location":"#1a-j-description","title":"1a-J Description","text":"<p>\u2003\u2003\u2003We used the <code>keySet()</code> method of the <code>HashMap</code> class to get a set view of the keys contained in our map, then we created a new stream from those keys so we could apply common stream operations like <code>mapToInt()</code> which maps a stream to an <code>IntStream</code> where we could also do things like <code>Integer.intValue()</code> which returns the value of the specified <code>Integer</code> object as an <code>int</code> primitive data type.  </p> <p>\u2003\u2003\u2003We also used <code>Integer.parseInt()</code> on the last example to return an <code>int</code> from a given string representation and applied <code>Arrays.copyOfRange()</code> to it so that the resulting array would only contain the first 3 keys of our map. For all our examples, we used the <code>toArray()</code> method at the end to get an array of all the elements of the <code>IntStream</code>.</p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#swap-keys-and-values-in-a-map","title":"Swap Keys And Values In A Map","text":"<p>\u2003\u2003\u2003I found these examples on Stack Overflow, which swap the keys and values contained in a map. I also got additional information about the <code>Collectors.groupingBy()</code> method on Stack Abuse.</p>"},{"location":"#2a-j-example","title":"2a-J Example","text":"<pre><code>import java.util.Map;\nimport java.util.List;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\n\nclass Main {\n    public static void main(String[] args) {\n        HashMap&lt;String, Integer&gt; cityMap = new HashMap&lt;&gt;();\n        cityMap.put(\"New York\", 20220928);\n        cityMap.put(\"Chicago\", 20220812);\n        cityMap.put(\"Boston\", 20220928);\n        cityMap.put(\"Los Angeles\", 20220928);\n        cityMap.put(\"Seattle\", 20221103);\n\n        Map&lt;Integer, List&lt;String&gt;&gt; dateMap = cityMap\n                .entrySet().stream().collect(Collectors  \n                .groupingBy(Map.Entry::getValue, Collectors  \n                .mapping(Map.Entry::getKey, Collectors.toList()))); \n\n        TreeMap&lt;Integer, List&lt;String&gt;&gt; sortedDateMap = cityMap  \n                .entrySet().stream().collect(Collectors  \n                .groupingBy(Map.Entry::getValue, TreeMap::new, \n                Collectors.mapping(Map.Entry::getKey, \n                                   Collectors.toList())));\n\n        /*\n         * Output:\n         * {20220928=[New York, Los Angeles, Boston], \n         *  20220812=[Chicago], 20221103=[Seattle]}\n         */\n        System.out.println(dateMap);\n\n        /*\n         * Output:\n         * {20220812=[Chicago], \n         *  20220928=[New York, Los Angeles, Boston], \n         *  20221103=[Seattle]}\n         */\n        System.out.println(sortedDateMap);\n    }\n}\n</code></pre>"},{"location":"#2a-j-description","title":"2a-J Description","text":"<p>\u2003\u2003\u2003First, the set view of the mappings was obtained to create a new stream, and then we applied the <code>Stream.collect()</code> method, which performed a mutable reduction operation on the elements of the stream. A mutable reduction operation collects input elements into a mutable container, such as a <code>Collection</code>, as it processes the elements of the stream.  </p> <p>\u2003\u2003\u2003We use the <code>Collectors.groupingBy()</code> method to return a <code>Collector</code> that groups objects by a given specific property and stores the end result in a map. The <code>Collector</code> makes a <code>Map&lt;K, List&lt;T&gt;&gt;</code>, whose keys are the values resulting from applying the classification function to the input elements. Each value of those keys is a <code>List</code> containing the input elements, which map to the associated key.  </p> <p>\u2003\u2003\u2003In the first example, we used <code>Entry.getValue()</code> as our classification function and <code>Collectors.mapping()</code> to apply a reduction operation to the values associated with a given key. Using <code>Entry.getKey()</code> as our mapping function, we're able to reduce our data to only use keys as values. Finally, <code>Collectors.toList()</code> was used as the downstream collector to accept the mapped values.  </p> <p>\u2003\u2003\u2003By doing all of the operations, we ended up with a <code>Map</code> instance that has the swapped key-value pairs from the initial map. Notice how we have duplicate values from our previous map, so when they're converted to keys, each of their previously associated keys is added inside a <code>List</code>. The second example was pretty much the same as the first; the only difference is that we've added a supplier method, <code>TreeMap::new</code>, which specifies the exact implementation of <code>Map</code> we want to use. This time it uses a <code>TreeMap</code> implementation, so the keys for our new map are automatically sorted.     </p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#convert-array-of-primitives-to-a-list-or-set","title":"Convert Array Of Primitives To A List Or Set","text":"<p>\u2003\u2003\u2003The information I used for these examples can be found on HowToDoInJava, which allows me to create a <code>List</code> or a <code>Set</code> from a stream of primitives.</p>"},{"location":"#3a-j-example","title":"3a-J Example","text":"<pre><code>import java.util.List;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.stream.Collectors;\n\nclass Main {\n    public static void main(String[] args) {\n        int[] nums = {1, 2, 3, 4, 5};\n\n        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(Arrays\n                .stream(nums).boxed().collect(Collectors.toSet()));\n\n        List&lt;Integer&gt; list = Arrays.stream(nums)\n                .boxed().collect(Collectors.toList());\n\n        // Output: [1, 2, 3, 4, 5]\n        System.out.println(set);\n\n        // Output: [1, 2, 3, 4, 5]\n        System.out.println(list);\n    }\n}\n</code></pre>"},{"location":"#3a-j-description","title":"3a-J Description","text":"<p>\u2003\u2003\u2003The array was first converted to a stream, and since it's a stream of primitives, we also needed to use the <code>boxed()</code> method to return a stream consisting of the elements of the given stream, each boxed to an object of the corresponding wrapper class, <code>Integer</code> in this case. Then we just apply the <code>Stream.collect()</code> method to create a <code>List</code> or use the result inside a constructor like the one from <code>HashSet</code>.     </p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#compare-wrapper-types","title":"Compare Wrapper Types","text":"<p>\u2003\u2003\u2003The information I used for these examples can be found on Stack Overflow, which shows why the <code>Integer</code> objects are not equal.</p>"},{"location":"#4a-j-example","title":"4a-J Example","text":"<pre><code>import java.util.HashMap;\n\nclass Main {\n    public static void main(String[] args) {\n        HashMap&lt;Character, Integer&gt; map1 = new HashMap&lt;&gt;();\n        HashMap&lt;Character, Integer&gt; map2 = new HashMap&lt;&gt;();\n\n        map1.put('N', 127);\n        map2.put('N', 127);\n\n        // Output: true\n        System.out.println(map1.get('N') \n                           == map2.get('N')); \n\n        map1.put('N', 128);\n        map2.put('N', 128);\n\n        // Output: false\n        System.out.println(map1.get('N') \n                           == map2.get('N')); \n\n        // Output: true\n        System.out.println(map1.get('N')\n                           .equals(map2.get('N'))); \n\n        Integer num = new Integer(2);\n\n        // Output: false\n        System.out.println(num == Integer.valueOf(2)); \n    }\n}\n</code></pre>"},{"location":"#4a-j-description","title":"4a-J Description","text":"<p>\u2003\u2003\u2003When comparing wrapper types such as <code>Integer</code>, <code>Long</code>, or <code>Boolean</code>, use <code>==</code> or <code>!=</code>, we're comparing them as references, not as values. The first example produces a value of <code>true</code> because in Java, numeric values within the range of -128 to 127 are cached, so they would have an identical memory location. For <code>Integer</code>, use <code>intValue()</code>, <code>compareTo()</code>, or <code>equals()</code> when making comparisons. If using wrapper classes like <code>Integer</code> can't be avoided, we can use the <code>Integer.valueOf()</code> method, which guarantees, as per the Java specs, the reuse of the first 256 <code>Integer</code> objects from -128 to 127, while <code>new Integer()</code> forces the creation of a new object, as shown in the last example.  </p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#nest-methods","title":"Nest Methods","text":"<p>\u2003\u2003\u2003The information I used for these examples can be found on GeeksforGeeks, which shows the different ways we could nest methods in Java.</p>"},{"location":"#5a-j-example","title":"5a-J Example","text":"<pre><code>class Main {\n    interface Build {\n        int factorial(int n);\n    }\n\n    public static void buildStr() {\n        StringBuilder sb = new StringBuilder(5);\n\n        Build builder = new Build() {\n            @Override\n            public int factorial(int n) {\n                if (n == 0 || n == 1) {\n                    return 1;\n                }\n\n                return n * factorial(n - 1);\n            };\n        };\n\n        for (int i = 0; i &lt; 5; i++) {\n            sb.append(builder.factorial(i));\n        }    \n\n        System.out.println(sb.toString());\n    }\n\n    public static void main(String[] args) {\n\n        // Output: 112624\n        buildStr(); \n    }\n}\n</code></pre>"},{"location":"#5a-j-description","title":"5a-J Description","text":"<p>\u2003\u2003\u2003Java does not support nested methods, so we used an anonymous subclass from the example above to achieve a similar structure. An anonymous class is an inner class without a name that usually extends subclasses or implements interfaces, and only a single object can be created from it.</p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#map-two-arrays-to-a-hashmap","title":"Map Two Arrays To A HashMap","text":"<p>\u2003\u2003\u2003The information I used for these examples can be found on Stack Overflow Link 1 and Stack Overflow Link 2, which allow sorting of the map as well.</p>"},{"location":"#6a-j-example","title":"6a-J Example","text":"<pre><code>import java.util.Map;\nimport java.util.TreeMap;\nimport java.util.LinkedHashMap;\nimport java.util.stream.IntStream;\nimport java.util.function.Supplier;\nimport static java.util.Comparator.comparing;\nimport static java.util.Comparator.reverseOrder;\nimport static java.util.stream.Collectors.toMap;\n\nclass Main {\n    public static void main(String[] args) {\n        int[] positions = {10, 8, 0, 5, 3};\n        int[] speeds = {2, 4, 1, 1, 3};\n\n        Map&lt;Integer, Integer&gt; velocities = IntStream\n                .range(0, positions.length).boxed()\n                .collect(toMap(i -&gt; positions[i], \n                               i -&gt; speeds[i]));\n\n        Map&lt;Integer, Integer&gt; velocitiesOrdered = IntStream\n                .range(0, positions.length).boxed()\n                .collect(toMap(i -&gt; positions[i], \n                               i -&gt; speeds[i], \n                               (i, j) -&gt; i, \n                               LinkedHashMap::new));\n\n        Map&lt;Integer, Integer&gt; velocitiesSorted = IntStream\n                .range(0, positions.length).boxed()\n                .sorted(comparing(i -&gt; positions[i]))\n                .collect(toMap(i -&gt; positions[i], \n                               i -&gt; speeds[i], \n                               (i, j) -&gt; i, \n                               LinkedHashMap::new));\n\n        Supplier&lt;TreeMap&lt;Integer, Integer&gt;&gt; mapSupplier = () \n                -&gt; new TreeMap&lt;&gt;(reverseOrder());\n\n        Map&lt;Integer, Integer&gt; velocitiesReverseSorted = IntStream\n                .range(0, positions.length).boxed()\n                .collect(toMap(i -&gt; positions[i], \n                               i -&gt; speeds[i], \n                               (i, j) -&gt; i, \n                               mapSupplier));\n\n        Map&lt;Integer, Integer&gt; velocitiesSpeedSorted = IntStream\n                .range(0, positions.length).boxed()\n                .sorted(comparing(i -&gt; speeds[i]))\n                .collect(toMap(i -&gt; positions[i], \n                               i -&gt; speeds[i], \n                               (i, j) -&gt; i, \n                               LinkedHashMap::new));\n\n        // Output: {0=1, 3=3, 5=1, 8=4, 10=2}\n        System.out.println(velocities);\n\n        // Output: {10=2, 8=4, 0=1, 5=1, 3=3}\n        System.out.println(velocitiesOrdered);\n\n        // Output: {0=1, 3=3, 5=1, 8=4, 10=2}\n        System.out.println(velocitiesSorted);\n\n        // Output: {10=2, 8=4, 5=1, 3=3, 0=1}\n        System.out.println(velocitiesReverseSorted);\n\n        // Output: {0=1, 5=1, 10=2, 3=3, 8=4}\n        System.out.println(velocitiesSpeedSorted);\n    }\n}\n</code></pre>"},{"location":"#6a-j-description","title":"6a-J Description","text":"<p>\u2003\u2003\u2003To use the <code>Collectors.toMap()</code> method, we have to box the <code>int</code> primitives into <code>Integer</code> objects first. To preserve the element order, use the extended version of <code>Collectors.toMap()</code> together with the <code>LinkedHashMap::new</code> function as the argument for the <code>mapSupplier</code> parameter, which was shown in the second example.  </p> <p>\u2003\u2003\u2003For the third example, we used the <code>Comparator.comparing</code> method to compare values from the positions array and sort them in ascending order; note how we also used the <code>LinkedHashMap::new</code> function for this example and the fifth example to maintain the sorted values when collecting them into a map.  </p> <p>\u2003\u2003\u2003We created a <code>TreeMap</code> with a <code>Comparator.reverseOrder</code> and used it as the <code>mapSupplier</code> for the fourth example to get a hashmap that has a descending order based on the values of the position array. Finally, we used the speed array as the basis for the sorting of the fifth example.      </p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#store-key-value-pairs-in-a-list","title":"Store Key-Value Pairs In A List","text":"<p>\u2003\u2003\u2003The information I used for these examples can be found on Techie Delight, which shows how to implement a <code>Pair</code> class.</p>"},{"location":"#7a-j-example","title":"7a-J Example","text":"<pre><code>import java.util.List;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.ArrayList;\n\nclass Main {\n    class Pair&lt;T, V&gt; {\n        private final T key;\n        private final V value;\n\n        public Pair(T key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public T getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n\n\n    class TimeMap {\n        HashMap&lt;String, List&lt;Pair&lt;String, Integer&gt;&gt;&gt; map;\n\n        public TimeMap() {\n            map = new HashMap&lt;&gt;();\n        }\n\n        public void set(String key, String value, int timestamp) {\n            if (!map.containsKey(key)) {\n                map.put(key, new ArrayList&lt;&gt;());\n            }\n\n            map.get(key).add(new Pair(value, timestamp));\n        }\n\n        public String get(String key) {\n            String res = \"\";\n\n            List&lt;Pair&lt;String, Integer&gt;&gt; list = map\n                    .getOrDefault(key, new ArrayList&lt;&gt;(0)); \n\n            for (Pair&lt;String, Integer&gt; p : list) {\n                res += \"[\" + p.getKey() + \", \" \n                       + p.getValue() + \"] \";\n            }\n\n            return res;\n        }\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main();\n        Main.TimeMap map = main.new TimeMap();\n        map.set(\"Server1\", \"User1\", 145);\n        map.set(\"Server1\", \"User2\", 565);\n        map.set(\"Server1\", \"User3\", 35);\n        map.set(\"Server1\", \"User4\", 13);\n        map.set(\"Server1\", \"User5\", 145);\n        map.set(\"Server2\", \"User1\", 23);\n        map.set(\"Server2\", \"User2\", 19);\n        map.set(\"Server2\", \"User3\", 61);\n\n        /*\n         * Output:\n         * [User1, 145] [User2, 565] [User3, 35]\n         * [User4, 13] [User5, 145]\n         */\n        System.out.println(map.get(\"Server1\"));\n\n        // Output: [User1, 23] [User2, 19] [User3, 61]\n        System.out.println(map.get(\"Server2\"));\n\n    }\n}\n</code></pre>"},{"location":"#7a-j-description","title":"7a-J Description","text":"<p>\u2003\u2003\u2003Java's <code>List</code> does not support key-value pairs, so we have to create a <code>Pair</code> custom class to be able to store them as elements. We can do this by using generics, so we can use different kinds of data for our keys and values. The created <code>List</code> would then be used by our <code>HashMap</code> to store values while also assigning its own key, as shown in the examples.    </p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#create-a-node-priority-queue-with-comparator","title":"Create A Node Priority Queue With Comparator","text":"<p>\u2003\u2003\u2003The information I used for these first examples can be found on GitHub, which is the Java solution for the LeetCode problem K Closest Points to Origin.</p>"},{"location":"#8a-j-example","title":"8a-J Example","text":"<pre><code>import java.util.Arrays;\nimport java.util.PriorityQueue;\n\nclass Main {\n    public int[][] kClosestMinHeap(int[][] points, int k) { \n        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) \n                -&gt; Double.compare(Math.pow(a[0], 2) \n                                  + Math.pow(a[1], 2),\n                                  Math.pow(b[0], 2) \n                                  + Math.pow(b[1], 2)));\n\n        for (int[] point : points) {\n            pq.offer(point);\n        }\n\n        int[][] res = new int[k][2]; \n\n        for (int i = 0; i &lt; k; i++) {\n            int[] cur = pq.poll();\n            res[i][0] = cur[0];\n            res[i][1] = cur[1];\n        }\n\n        return res;\n    }\n\n    public int[][] kClosestMaxHeap(int[][] points, int k) { \n        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) \n                -&gt; Double.compare(Math.pow(b[0], 2) \n                                  + Math.pow(b[1], 2),\n                                  Math.pow(a[0], 2) \n                                  + Math.pow(a[1], 2)));\n\n        for (int[] point : points) {\n            pq.offer(point);\n\n            if (pq.size() &gt; k) {\n                pq.poll();\n            }\n        }\n\n        int[][] res = new int[k][2]; \n\n        for (int i = 0; i &lt; k; i++) {\n            int[] cur = pq.poll();\n            res[i][0] = cur[0];\n            res[i][1] = cur[1];\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main();\n        int[][] points = {{3, 3}, {5, -1}, {-2, 4}};\n\n        // Output: [[3, 3], [-2, 4]]\n        System.out.println(Arrays.deepToString(main\n                .kClosestMinHeap(points, 2)));\n\n        // Output: [[-2, 4], [3, 3]]\n        System.out.println(Arrays.deepToString(main\n                .kClosestMaxHeap(points, 2)));\n    }\n}\n</code></pre>"},{"location":"#8a-j-description","title":"8a-J Description","text":"<p>\u2003\u2003\u2003The examples above return the k closest points to the origin of an X-Y plane (0, 0) from a given set of coordinates. To solve the problem, we'll use a heap binary tree data structure, which is implemented as the <code>PriorityQueue</code> in Java. We could then pass a <code>Comparator</code> when instantiating to give rules on how we would want to order the elements that would be stored inside the <code>PriorityQueue</code>.</p> <p>\u2003\u2003\u2003Instead of creating a new <code>Comparator</code> object, we could just use Java 8's lambda expression feature to declare how our comparisons would work. We also used the Euclidean formula to calculate the distance of the points from the origin (note that we didn't apply the square root to the formula because it wouldn't affect our desired results). In the first example, we created what's called a min heap because the points would be ordered in an ascending order based on the results of the formula. We then continuously popped the head of the <code>PriorityQueue</code> and assigned its values to the indexes of our <code>res</code> 2D array until we had enough k elements, which we would then finally return as our result.  </p> <p>\u2003\u2003\u2003We could save more space by using a max heap instead of a min heap, as shown in the second example; we were able to convert the <code>Comparator</code> for the max heap by flipping the conditions where we have the second array in our lambda expression as the first argument in our <code>Double.compare()</code> method (note that we used <code>Double</code> instead of <code>Integer</code> because the <code>Math.pow()</code> method returns a <code>double</code> value).</p> <p>(back to top \u2934\ufe0f)</p> <p>\u2003\u2003\u2003The information I used for the next examples can be found on Stack Overflow Link 1, which shows why using the commented line (see code below) would cause an overflow when trying to get the difference of two large arbitrary signed integers, thus causing unexpected behaviors. Stack Overflow Link 2 shows how to implement the <code>Comparable</code> interface to avoid such problems.</p>"},{"location":"#8b-j-example","title":"8b-J Example","text":"<pre><code>import java.util.PriorityQueue;\n\nclass Main {\n    class ListNode implements Comparable&lt;ListNode&gt; {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n\n        @Override\n        public int compareTo(ListNode n) {\n            if (this.val &lt; n.val) {\n                return -1;\n            } else if (this.val &gt; n.val) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n\n        @Override\n        public String toString() {\n            String result = val + \" -&gt; \";\n\n            if (next != null) {\n                result += next.toString();\n            }\n\n            return result;\n        }\n    }\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n\n        // PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;((a, b) \n        //         -&gt; a.val - b.val);\n        PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;((a, b) \n                -&gt; a.compareTo(b));\n\n        for (ListNode n : lists) {\n            if (n != null) {\n                queue.offer(n);  \n            } \n        }\n\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n\n        while (!queue.isEmpty()) {\n            ListNode n = queue.poll();\n            curr.next = n;\n            curr = curr.next;\n\n            if (n.next != null) {\n                queue.offer(n.next);\n            }\n        }\n\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main();\n\n        // List Node 1\n        Main.ListNode list1Tail = main.new ListNode(5);\n        Main.ListNode list1N = main.new ListNode(4, list1Tail);\n        Main.ListNode list1Head = main.new ListNode(1, list1N);\n\n        // List Node 2\n        Main.ListNode list2Tail = main.new ListNode(4);\n        Main.ListNode list2N = main.new ListNode(3, list2Tail);\n        Main.ListNode list2Head = main.new ListNode(1, list2N);\n\n        // List Node 3\n        Main.ListNode list3Tail = main.new ListNode(6);\n        Main.ListNode list3Head = main.new ListNode(2, list3Tail);\n\n        ListNode[] lists = {list1Head, list2Head, list3Head};\n        ListNode mergedListsHead = main.mergeKLists(lists);\n\n        // Output: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6 -&gt;\n        System.out.println(mergedListsHead.toString());\n    }\n}\n</code></pre>"},{"location":"#8b-j-description","title":"8b-J Description","text":"<p>\u2003\u2003\u2003The example above merges sorted list nodes together, where List Nodes 1 and 2 have three nodes while List Node 3 only has a head and a tail. We can implement the code in two ways, but the commented line does not work in general because there's a chance that it would cause an overflow when the variable <code>a</code> in the lambda expression is a large positive number while the <code>b</code> variable is a large negative number, resulting in having to add the two large numbers together, which the <code>int</code> data type might not be able to hold, and the answer would instead be a negative integer instead of a positive one, giving the opposite of the intended behavior.  </p> <p>\u2003\u2003\u2003To solve the previous problem, we must implement the <code>Comparable</code> interface on our <code>ListNode</code> class, which allows us to implement our own <code>compareTo</code> function without having to subtract two integers to get a positive or negative result.</p> <p>\u2003\u2003\u2003This method of creating a comparator for the <code>PriorityQueue</code> is preferred over the examples in 9a when the elements used are not <code>Comparable</code> out of the box (e.g., custom classes).</p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#create-a-hashset-of-arrays","title":"Create A HashSet Of Arrays","text":"<p>\u2003\u2003\u2003The information I used for this example can be found on Stack Overflow, which shows different ways to implement a <code>HashSet</code> containing arrays or collections as elements.</p>"},{"location":"#9a-j-example","title":"9a-J Example","text":"<pre><code>import java.util.List;\nimport java.util.HashSet;\n\nclass Main {\n    public static void main(String[] args) {\n        int x = 0;\n        int y = 1;\n        int[] arr1 = {x, y};\n        int[] arr2 = {x, y};\n        List&lt;Integer&gt; list1 = List.of(x, y);\n        List&lt;Integer&gt; list2 = List.of(x, y);\n        HashSet&lt;int[]&gt; set1 = new HashSet&lt;&gt;();\n        HashSet&lt;List&lt;Integer&gt;&gt; set2 = new HashSet&lt;&gt;();\n\n        set1.add(arr1);\n\n        // Output: false\n        System.out.println(set1.contains(arr2));\n\n        set2.add(list1);\n\n        // Output: true\n        System.out.println(set2.contains(list2)); \n    }\n}\n</code></pre>"},{"location":"#9a-j-description","title":"9a-J Description","text":"<p>\u2003\u2003\u2003In the above example, we're creating two <code>HashSet</code> objects, one of which accepts <code>int[]</code> elements while the other accepts <code>List&lt;Integer&gt;</code>. Since <code>int[]</code> is not a primitive data type, when creating a new array from the <code>x</code> and <code>y</code> variables and then invoking the <code>contains</code> function of <code>set1</code>, the default behavior of the function would be to compare the reference of the objects instead of their contents, which is why we're getting a <code>false</code> result. To fix this, we can use a <code>List</code> instead of an array because it's an object that implements the <code>equals()</code> method based on its contents (note that <code>set2</code> uses more space since it stores <code>Integer</code> objects; check this link for a better implementation that uses a custom class).</p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#lexicographically-sort-a-2d-list","title":"Lexicographically Sort A 2D List","text":"<p>\u2003\u2003\u2003The information I used for this example can be found on Stack Overflow, which shows how to sort a 2D array that has two elements per array lexicographically using Java 8's lambda function to create a <code>Comparator</code>.</p>"},{"location":"#10a-j-example","title":"10a-J Example","text":"<pre><code>import java.util.List;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Main {\n    public static void main(String[] args) {\n        List&lt;List&lt;String&gt;&gt; tickets = new ArrayList&lt;&gt;(List\n                .of(List.of(\"JFK\", \"SFO\"),\n                    List.of(\"ATL\", \"JFK\"),\n                    List.of(\"SFO\", \"ATL\"),\n                    List.of(\"JFK\", \"ATL\"),\n                    List.of(\"ATL\", \"SFO\")));\n\n        /*\n         * Output:\n         * [[JFK, SFO], [ATL, JFK], [SFO, ATL], \n         *  [JFK, ATL], [ATL, SFO]] \n         */\n        System.out.println(Arrays\n                           .deepToString(tickets.toArray()));\n\n        Collections.sort(tickets, (a, b) -&gt; {\n            if (a.get(0).equals(b.get(0))) {\n                return a.get(1).compareTo(b.get(1));\n            }\n\n            return a.get(0).compareTo(b.get(0));\n        });\n\n        /*\n         * Output:\n         * [[ATL, JFK], [ATL, SFO], [JFK, ATL], \n         *  [JFK, SFO], [SFO, ATL]]\n         */\n        System.out.println(Arrays\n                           .deepToString(tickets.toArray()));\n    }\n}\n</code></pre>"},{"location":"#10a-j-description","title":"10a-J Description","text":"<p>\u2003\u2003\u2003In the above example, we're trying to sort a 2D <code>List</code> of tickets that contains the abbreviations of states for the source location and destination pairs. We'll sort the tickets in lexicographical order based on their source location, and if they're exactly the same, their destination will be used instead. We used the <code>Collections.sort()</code> method to sort the <code>List</code> of tickets and provided it with a <code>Comparator</code> in the form of a lambda expression that has the logic that allows us to compare the second elements of the ticket lists if their first elements are the same.</p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#iterate-through-a-hashmap","title":"Iterate Through A HashMap","text":"<p>\u2003\u2003\u2003The information I used for this example can be found on Stack Overflow, which shows different ways to iterate through the elements of a <code>HashMap</code>.</p>"},{"location":"#11a-j-example","title":"11a-J Example","text":"<pre><code>import java.util.Map;\nimport java.util.HashSet;\nimport java.util.HashMap;\n\nclass Main {\n    public static void main(String[] args) {\n        String alienWord = \"wertf\";\n\n        HashMap&lt;Character, HashSet&lt;Character&gt;&gt; charMap \n        = new HashMap&lt;&gt;();\n\n        for (int i = 0; i &lt; alienWord.length() - 1; i++) {\n            for (char letter : alienWord.substring(i + 1)\n                                        .toCharArray()) {\n                charMap.computeIfAbsent(alienWord.charAt(i), \n                                        k -&gt; new HashSet&lt;&gt;())\n                       .add(letter); \n            }\n        }\n\n        /*\n         * Output:\n         * r: [t, f] \n         * t: [f]\n         * e: [r, t, f]\n         * w: [r, t, e, f]\n         */\n        for (Map.Entry&lt;Character, HashSet&lt;Character&gt;&gt; set \n                : charMap.entrySet()) {\n            System.out.println(set.getKey() + \": \" \n                               + set.getValue());\n        }\n\n        // Output: r t e w \n        for (char c : charMap.keySet()) {\n            System.out.print(c + \" \");\n        }\n\n        /*\n         * Output:\n         * r: [t, f] \n         * t: [f]\n         * e: [r, t, f]\n         * w: [r, t, e, f]\n         */\n        charMap.forEach((k, v) \n                        -&gt; System.out.println(k + \": \" + v));\n    }\n}\n</code></pre>"},{"location":"#11a-j-description","title":"11a-J Description","text":"<p>\u2003\u2003\u2003In the above example, we're trying to map the characters of the <code>alienWord</code> variable to its substrings and print them out as the contents of a <code>HashMap</code>. We can do this by using the <code>entrySet()</code> method of our <code>HashMap</code>, which returns a <code>Set</code> view of the mappings that we can iterate over, as shown in the first example, while the second example shows how we can iterate only in the keys by using the <code>keySet()</code> method, and the last example shows how we can do the first example using Java 8's lambda function.</p> <p>(back to top \u2934\ufe0f)</p>"},{"location":"#map-characters-to-an-array","title":"Map Characters To An Array","text":"<p>\u2003\u2003\u2003The information I used for this example can be found on GeeksforGeeks, which shows how to sort a string of characters by using the following method, and Stack Overflow, which shows how to convert an integer to a character.</p>"},{"location":"#12a-j-example","title":"12a-J Example","text":"<pre><code>class Main {\n    public static void main(String[] args) {\n        String alienWord = \"wertf\";\n        boolean[] alphabets = new boolean[26];\n\n        for (char c : alienWord.toCharArray()) {\n            alphabets[c - 'a'] = true;\n        }\n\n        // Output: efrtw\n        for (int i = 0; i &lt; alphabets.length; i++) {\n            if (alphabets[i]) {\n                System.out.print((char) (i + '0' + 49));\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"#12a-j-description","title":"12a-J Description","text":"<p>\u2003\u2003\u2003In the above example, we're trying to map the characters of the <code>alienWord</code> variable to an array by converting them to integers, which would serve as their index on the array. We can do this by subtracting their <code>ASCII</code> numeric value from that of the character <code>'a'</code>, so <code>'a' - 'a'</code> would yield a result of zero, meaning that the <code>boolean</code> value that represents whether or not that character exists in the <code>alienWord</code> variable would be stored at that index in the array (note that our array has a fixed size of <code>26</code> since there are only <code>26</code> letters in the English alphabet), which has a default value of <code>false</code> and would be set to <code>true</code> as the resulting index was accessed in the array.</p> <p>\u2003\u2003\u2003Once all of the array indexes correlating to characters in the word have been marked <code>true</code>, the program would convert said indexes back to their character equivalent by adding to them the <code>ASCII</code> numeric value of <code>'0'</code> and increasing the result by <code>49</code> to get back the <code>ASCII</code> numeric value of the character <code>'a'</code> onwards. For example, <code>0 + '0'</code> is equal to <code>48</code>, and adding <code>49</code> to it would result in <code>97</code>, which is the <code>ASCII</code> value for the character <code>'a'</code> (note that the resulting string printed doesn't have the exact same order as the original one since the characters are mapped to their equivalant index based on their position on the English alphabet).</p> <p>(back to top \u2934\ufe0f)</p>"}]}